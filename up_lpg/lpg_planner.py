import pkg_resources
import re
import unified_planning
from unified_planning.shortcuts import *
from unified_planning.solvers import PDDLSolver
from unified_planning.exceptions import UPException
from typing import List


class LPGsolver(PDDLSolver):

    def destroy(self):
        pass

    def __init__(self):
        super().__init__()
        self._needs_requirements = False

    @staticmethod
    def name() -> str:
        return 'lpg'

    def _get_cmd(self, domain_filename: str, problem_filename: str, plan_filename: str) -> List[str]:
        base_command = [pkg_resources.resource_filename(__name__, 'lpg'), '-o', domain_filename, '-f', problem_filename, '-n', '1', '-out', plan_filename]
        return base_command


    def manage_parameters(self, command):
        #if self.search_algorithm is not None:
        #    command += ['-s', self.search_algorithm]
        return command


    def _plan_from_file(self, problem: 'unified_planning.model.Problem', plan_filename: str) -> 'unified_planning.plan.Plan':
        actions = []
        with open(plan_filename) as plan:
            for line in plan.readlines():
                if re.match(r'^\s*(;.*)?$', line):
                    continue
                res = re.match(r'^\d+:\s*\(\s*([\w?-]+)((\s+[\w?-]+)*)\s*\)\s*\[\d+\]$', line.lower())
                if res:
                    action = problem.action(res.group(1))
                    parameters = []
                    for p in res.group(2).split():
                        parameters.append(ObjectExp(problem.object(p)))
                    actions.append(unified_planning.plan.ActionInstance(action, tuple(parameters)))
                else:
                    raise UPException('Error parsing plan generated by ' + self.__class__.__name__)
        return unified_planning.plan.SequentialPlan(actions)

    
    def _result_status(self, problem: 'unified_planning.model.Problem', plan: Optional['unified_planning.plan.Plan']) -> int:
        '''Takes a problem and a plan and returns the status that represents this plan.
        The possible status with their interpretation can be found in the up.plan file.'''
        return unified_planning.solvers.results.PlanGenerationResultStatus.UNSOLVABLE_INCOMPLETELY if plan is None else unified_planning.solvers.results.PlanGenerationResultStatus.SOLVED_SATISFICING

    @staticmethod
    def supports(problem_kind: 'ProblemKind') -> bool:
        supported_kind = ProblemKind()
        supported_kind.set_numbers('CONTINUOUS_NUMBERS')  # type: ignore
        supported_kind.set_typing('FLAT_TYPING')  # type: ignore
        supported_kind.set_fluents_type('NUMERIC_FLUENTS')  # type: ignore
        # supported_kind.set_conditions_kind('NEGATIVE_CONDITIONS')  # type: ignore
        # supported_kind.set_conditions_kind('DISJUNCTIVE_CONDITIONS')  # type: ignore
        supported_kind.set_conditions_kind('EQUALITY')  # type: ignore
        supported_kind.set_numbers('DISCRETE_NUMBERS')  # type: ignore
        supported_kind.set_effects_kind('INCREASE_EFFECTS')  # type: ignore
        return problem_kind <= supported_kind

    @staticmethod
    def is_grounder() -> bool:
        return False

    @staticmethod
    def is_oneshot_planner() -> bool:
        return True

    @staticmethod
    def is_plan_validator() -> bool:
        return False


